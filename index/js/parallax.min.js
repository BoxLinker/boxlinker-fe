/*!
 * parallax.js v1.3.1 (http://pixelcog.github.io/parallax.js/)
 * @copyright 2015 PixelCog, Inc.
 * @license MIT (https://github.com/pixelcog/parallax.js/blob/master/LICENSE)
 */
!(function(t, i, e, s) {
  function o(i, e) {
    const h = this;
    typeof e === 'object' &&
      (
        delete e.refresh,
        delete e.render,
        t.extend(this, e)
      ), (this.$element = t(i)), !this.imageSrc &&
      this.$element.is('img') &&
      (this.imageSrc = this.$element.attr('src'));
    let r = `${this.position}`.toLowerCase().match(/\S+/g) || [];
    return r.length < 1 && r.push('center'), r.length == 1 &&
      r.push(r[0]), (r[0] == 'top' ||
      r[0] == 'bottom' ||
      r[1] == 'left' ||
      r[1] == 'right') &&
      (r = [r[1], r[0]]), this.positionX != s &&
      (r[0] = this.positionX.toLowerCase()), this.positionY != s &&
      (r[1] = this.positionY.toLowerCase()), (h.positionX =
      r[0]), (h.positionY = r[1]), this.positionX != 'left' &&
      this.positionX != 'right' &&
      (this.positionX = isNaN(parseInt(this.positionX))
        ? 'center'
        : parseInt(this.positionX)), this.positionY != 'top' &&
      this.positionY != 'bottom' &&
      (this.positionY = isNaN(parseInt(this.positionY))
        ? 'center'
        : parseInt(this.positionY)), (this.position = `${this.positionX +
      (isNaN(this.positionX) ? '' : 'px')} ${this.positionY}${isNaN(
      this.positionY,
    )
      ? ''
      : 'px'}`), navigator.userAgent.match(/(iPod|iPhone|iPad)/)
      ? (
          this.iosFix &&
            !this.$element.is('img') &&
            this.$element.css({
              backgroundImage: `url(${this.imageSrc})`,
              backgroundSize: 'cover',
              backgroundPosition: this.position,
            }),
          this
        )
      : navigator.userAgent.match(/(Android)/)
        ? (
            this.androidFix &&
              !this.$element.is('img') &&
              this.$element.css({
                backgroundImage: `url(${this.imageSrc})`,
                backgroundSize: 'cover',
                backgroundPosition: this.position,
              }),
            this
          )
        : (
            (this.$mirror = t('<div />').prependTo('body')),
            (this.$slider = t('<img />').prependTo(this.$mirror)),
            this.$mirror.addClass('parallax-mirror').css({
              visibility: 'hidden',
              zIndex: this.zIndex,
              position: 'fixed',
              top: 0,
              left: 0,
              overflow: 'hidden',
            }),
            this.$slider.addClass('parallax-slider').one('load', function() {
              (h.naturalHeight && h.naturalWidth) ||
                (
                  (h.naturalHeight = this.naturalHeight || this.height || 1),
                  (h.naturalWidth = this.naturalWidth || this.width || 1)
                ), (h.aspectRatio = h.naturalWidth / h.naturalHeight), o.isSetup || o.setup(), o.sliders.push(h), (o.isFresh = !1), o.requestRender();
            }),
            (this.$slider[0].src = this.imageSrc),
            void (
              ((this.naturalHeight && this.naturalWidth) ||
                this.$slider[0].complete) &&
              this.$slider.trigger('load')
            )
          );
  }
  function h(s) {
    return this.each(function() {
      let h = t(this),
        r = typeof s === 'object' && s;
      this == i || this == e || h.is('body')
        ? o.configure(r)
        : h.data('px.parallax') ||
          (
            (r = t.extend({}, h.data(), r)),
            h.data('px.parallax', new o(this, r))
          ), typeof s === 'string' && o[s]();
    });
  }
  !(function() {
    for (
      var t = 0, e = ['ms', 'moz', 'webkit', 'o'], s = 0;
      s < e.length && !i.requestAnimationFrame;
      ++s
    )
      (i.requestAnimationFrame =
        i[`${e[s]}RequestAnimationFrame`]), (i.cancelAnimationFrame =
        i[`${e[s]}CancelAnimationFrame`] ||
        i[`${e[s]}CancelRequestAnimationFrame`]);
    i.requestAnimationFrame ||
      (i.requestAnimationFrame = function(e) {
        let s = new Date().getTime(),
          o = Math.max(0, 16 - (s - t)),
          h = i.setTimeout(() => {
            e(s + o);
          }, o);
        return (t = s + o), h;
      }), i.cancelAnimationFrame ||
      (i.cancelAnimationFrame = function(t) {
        clearTimeout(t);
      });
  })(), t.extend(o.prototype, {
    speed: 0.2,
    bleed: 0,
    zIndex: -100,
    iosFix: !0,
    androidFix: !0,
    position: 'center',
    overScrollFix: !1,
    refresh() {
      (this.boxWidth = this.$element.outerWidth()), (this.boxHeight =
        this.$element.outerHeight() + 2 * this.bleed), (this.boxOffsetTop =
        this.$element.offset().top -
        this
          .bleed), (this.boxOffsetLeft = this.$element.offset().left), (this.boxOffsetBottom =
        this.boxOffsetTop + this.boxHeight);
      let t = o.winHeight,
        i = o.docHeight,
        e = Math.min(this.boxOffsetTop, i - t),
        s = Math.max(this.boxOffsetTop + this.boxHeight - t, 0),
        h = (this.boxHeight + (e - s) * (1 - this.speed)) | 0,
        r = ((this.boxOffsetTop - e) * (1 - this.speed)) | 0;
      if (h * this.aspectRatio >= this.boxWidth) {
        (this.imageWidth =
          (h * this.aspectRatio) |
          0), (this.imageHeight = h), (this.offsetBaseTop = r);
        var n = this.imageWidth - this.boxWidth;
        this.offsetLeft =
          this.positionX == 'left'
            ? 0
            : this.positionX == 'right'
              ? -n
              : isNaN(this.positionX)
                ? (-n / 2) | 0
                : Math.max(this.positionX, -n);
      } else {
        (this.imageWidth = this.boxWidth), (this.imageHeight =
          (this.boxWidth / this.aspectRatio) | 0), (this.offsetLeft = 0);
        var n = this.imageHeight - h;
        this.offsetBaseTop =
          this.positionY == 'top'
            ? r
            : this.positionY == 'bottom'
              ? r - n
              : isNaN(this.positionY)
                ? (r - n / 2) | 0
                : r + Math.max(this.positionY, -n);
      }
    },
    render() {
      let t = o.scrollTop,
        i = o.scrollLeft,
        e = this.overScrollFix ? o.overScroll : 0,
        s = t + o.winHeight;
      (this.visibility =
        this.boxOffsetBottom > t && this.boxOffsetTop < s
          ? 'visible'
          : 'hidden'), (this.mirrorTop =
        this.boxOffsetTop - t), (this.mirrorLeft =
        this.boxOffsetLeft - i), (this.offsetTop =
        this.offsetBaseTop -
        this.mirrorTop * (1 - this.speed)), this.$mirror.css({
        transform: 'translate3d(0px, 0px, 0px)',
        visibility: this.visibility,
        top: this.mirrorTop - e,
        left: this.mirrorLeft,
        height: this.boxHeight,
        width: this.boxWidth,
      }), this.$slider.css({
        transform: 'translate3d(0px, 0px, 0px)',
        position: 'absolute',
        top: this.offsetTop,
        left: this.offsetLeft,
        height: this.imageHeight,
        width: this.imageWidth,
        maxWidth: 'none',
      });
    },
  }), t.extend(o, {
    scrollTop: 0,
    scrollLeft: 0,
    winHeight: 0,
    winWidth: 0,
    docHeight: 1 << 30,
    docWidth: 1 << 30,
    sliders: [],
    isReady: !1,
    isFresh: !1,
    isBusy: !1,
    setup() {
      if (!this.isReady) {
        let s = t(e),
          h = t(i);
        h
          .on('scroll.px.parallax load.px.parallax', () => {
            let t = o.docHeight - o.winHeight,
              i = o.docWidth - o.winWidth;
            (o.scrollTop = Math.max(
              0,
              Math.min(t, h.scrollTop()),
            )), (o.scrollLeft = Math.max(
              0,
              Math.min(i, h.scrollLeft()),
            )), (o.overScroll = Math.max(
              h.scrollTop() - t,
              Math.min(h.scrollTop(), 0),
            )), o.requestRender();
          })
          .on('resize.px.parallax load.px.parallax', () => {
            (o.winHeight = h.height()), (o.winWidth = h.width()), (o.docHeight = s.height()), (o.docWidth = s.width()), (o.isFresh = !1), o.requestRender();
          }), (this.isReady = !0);
      }
    },
    configure(i) {
      typeof i === 'object' &&
        (delete i.refresh, delete i.render, t.extend(this.prototype, i));
    },
    refresh() {
      t.each(this.sliders, function() {
        this.refresh();
      }), (this.isFresh = !0);
    },
    render() {
      this.isFresh || this.refresh(), t.each(this.sliders, function() {
        this.render();
      });
    },
    requestRender() {
      const t = this;
      this.isBusy ||
        (
          (this.isBusy = !0),
          i.requestAnimationFrame(() => {
            t.render(), (t.isBusy = !1);
          })
        );
    },
  });
  const r = t.fn.parallax;
  (t.fn.parallax = h), (t.fn.parallax.Constructor = o), (t.fn.parallax.noConflict = function() {
    return (t.fn.parallax = r), this;
  }), t(e).on('ready.px.parallax.data-api', () => {
    t('[data-parallax="scroll"]').parallax();
  });
})(jQuery, window, document);
